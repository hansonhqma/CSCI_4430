# CSCI 4430 Lecture 2

## Syntax vs Semantics

**Syntax**: form, or structure of expressions, statments, and program units of a language

`while(expr){statement;}`

Is the syntax of a while loop in C-family languages

**Semantics**: meaning of expressions, statements, and program units of a languages: the semantics of 

`while(expr){statement;}`

Is "execute `statement` repeatedly whilest `expr` remains `True`"

## Some automata theory

- A *language* is a set of strings (called sentences) generated from a finite alphabet (finite set of characters)
- A *generator* is the set of rules that generate the strings in the language
- A *recognizer* reads strings as input and determines whether or not they could have been generated by the language

## Classes of formal languages

**Languages are characterized by the complexity of generation/recognition rules**.

The Chomsky hierarchy, in order of complexity:

1. Regular languages
   - Describe tokens in programming languages (keywords, identifiers, literals)
   - Regex's generate regular languages
   - Can be recognized with a finite automata (scanner in compilers)
2. Context-free languages
   - Describe more complex programming language schemes (expressions, statements)
   - Generated by context-free grammar
   - Recognized by push-down automaton (parser in compilers)
3. Context-sensitive languages
4. Recursively enumerable languages

Past context-free languages, generators and recognizers become very complex

### Motivation for formal languages

Can enable the classification, or proof of difficulty among computational problems

Basically, **formal languages are the contructs that describe programming languages**
- Using fl's, we can build scanners, parsers, and compilers as a whole
- Central problem is building efficient ones

## Regular expressions

Simplest structure, describes regular languages, identifies tokens in programming languages

- Symbols, `+`, `-`, etc.
- Identifers `foo`, `bar`, etc.
- Literals `20`, `False`, etc.

Are all tokens

As stated above, tokens in a programming language form a regular language, generated by regular expressions, recognized by finite automata

**A regular expression is one of the following:**

- Singular character
- Empty string $\epsilon$
- Multiple regular expressions concatenated with each other
- The union of regular expressions
- Kleene star

Suppose we have the regex `a|b`, which represents the string set `{a,b}`, and the regex `aa|bb` which represents the string set `{aa, bb}`.

If we define the regex `(a|b) (aa|bb)`, this is the set of all strings `a` or `b` followed by the strings `aa` or `bb`:

`(a|b) (aa|bb) = {aaa, abb, baa, bbb}`

The operator `*` is a multiple concatenation operator:

For some regex `L`, the regex `L*` is the concatenation of 0 to infinite strings generated by `L`.

For example, `a*` generates the set of strings `{a, aa, aaa, ...}`

## Grammars

A grammar consists of:

|**Element**|**Description**|
|-|-|
|Terminals     |Characters in the alphabet      |
|Non-terminals |Represent language constructs   |
|Productions   |Rules for forming contructs in correct syntax|
|Start symbol  |Sign for where to start applying rules|

### Regular grammars
- Regular grammars generate regular languages
- These regular grammars follow a particular form:
   - each lhs has exactly one non-terminal
   - each rhs is one of the following:
      - Single terminal symbol
      - Single non-terminal symbo
      - A non-terminal followed by a terminal

E.g: the regular language generated by the regex `1 2* | 0*` can be described by a grammar as:

```
S -> A | B
A -> 1 | A 2
B -> 0 | B 0
```

This is a valid regular grammar since it follows the particular form listed above.

The following is not a regular grammar:
```
S -> 0 A
A -> S 1
S -> e
```

Since on line 1 we have a terminal followed by a non-terminal, violates the particular form listed above

Instead it is a context-free grammar

### Context-free grammars

Regular languages cannot specify all contructs in programming - try to write a regex that specifies valid arithmetic expressions, you can't

Context-free grammars (CFG) generate context-free languages
- Most of what's needed in programming languages can be specified by CFG's

CFG's have the form:
- LHS has exactly one non-terminal
- RHS has arbitrary permutation of terminals and non-terminals

E.g: the grammar `0^n 1^n, n > 0` is a context-free grammar and not a regular grammar since the empty string isn't generated by it - no regex exists to generate such a grammar. The CFG that generates this is
```
S -> 0 S 1
S -> 0 1
```

In the analysis of programming languages and compilters, we are concerned with two special CFG's:
- LL
- LR

Suppose we have a simple CFG for arithmetic expressions:
```
expr -> id | (expr) | expr op expr
op -> + | *
```

Using this CFG, we can generate, or **derive** expressions: how might we derive the expression `id * id + id`?
```
expr
expr op expr
expr op id
expr + id
expr op expr + id
expr op id + id
expr * id + id
id * id + id
```

A **derivation** of a string from a CFG is the process that starts with the start symbol, and at each step replaces a nonterminal with the RHS of its respective production

At each intermediate step, we have a **sentential form**. The completed string is sometimes called the yield.

Let us group derivations into two categories:
- Left-most derivation:
   Replaces left-most nonterminal in a sentential form at each step
- Right-most derivation:
   Replaces right-most nonterminal in a sentential form at each step

Now we ask the question, can we go backwards? From a yield to a start symbol. This is possible and is called a **parse**, the reverse of a derivation

A **parse tree** is the tree graph of replacements where the root node is the start symbol, non-leaf nodes are nonterminals, and leaf nodes are terminals. When multiple of these parse trees exists for a particular string, the grammar is called **ambiguous**.

There is no algorithm that can tell is some arbitrary CFG is ambiguous or not.

**Ambiguity in grammars is bad!**

## Expression grammars

Generate expressoins
- Arithmetic expressions
- Regular expressions
- Other

Terminals of this grammar include operands, operators, and parentheses